#!/usr/bin/env node
var Z=Object.create;var N=Object.defineProperty;var ee=Object.getOwnPropertyDescriptor;var te=Object.getOwnPropertyNames;var se=Object.getPrototypeOf,ne=Object.prototype.hasOwnProperty;var ie=(s,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of te(e))!ne.call(s,a)&&a!==t&&N(s,a,{get:()=>e[a],enumerable:!(n=ee(e,a))||n.enumerable});return s};var k=(s,e,t)=>(t=s!=null?Z(se(s)):{},ie(e||!s||!s.__esModule?N(t,"default",{value:s,enumerable:!0}):t,s));var G=require("process");var V=k(require("path")),P=k(require("semver")),x=k(require("inquirer")),g=require("process");var I="No Description",C=!1,R=!1,M=!1,ae=!1,oe={useLoopback:M,useVerbose:ae,useShell:R,useDebug:C,description:I},re=async(s,e,{useLoopback:t=M,useShell:n=R,useDebug:a=C,description:r=I,useVerbose:i=!1}=oe)=>{let o={exitCode:1,error:Error(),errorMsg:"",pipe:[]};try{try{i&&(console.log(`Starting Operation: "${r}"`),a&&console.log("	",e,...e))}catch{}let p=await s(...e);o.pipe=t?p:[p],o.exitCode=0;try{i&&(console.log(`Finished Operation: "${r}"`),a&&console.log("	",p))}catch{}}catch(p){o.exitCode=1,n&&typeof p=="object"&&p!==null&&("status"in p&&typeof p.status=="number"?o.exitCode=p.status:"code"in p&&typeof p.code=="number"&&(o.exitCode=p.code)),p instanceof Error&&(o.error=p),o.errorMsg=`ERROR! Error type: ${o.error.name}
Name of the Operation that failed: "${r}"
Error exit code: ${o.exitCode}
Error output: ${o.error}`,a&&console.error(o.errorMsg)}return o},pe=(s,e)=>t=>re(s,t,e),d=class s{isMutable=!0;queue=[];fallbackOps=new WeakMap;trace;isPipelineFlagSet=new WeakSet;env;constructor(e,t){this.env=Object.freeze(Object.assign({useLoopback:!1,useShell:!1,useDebug:!1,useEmptyLoopback:!0,useNestingDebug:!1,description:e},t,t&&t.useNestingLog&&!t.useLog&&{useLog:t.useNestingLog},t&&t.useNestingVerbose&&!t.useVerbose&&{useVerbose:t.useNestingVerbose},t&&t.useNestingDebug&&!t.useDebug&&{useDebug:t.useNestingDebug},t&&t.useNestingSilent&&!t.useSilent&&{useSilent:t.useNestingSilent})),this.env.useDebug&&(this.trace={pipelineInputs:[],pipelineOutputs:[],pipelineInstanceInfo:[],enqueueChildDescriptions:[],enqueueLocalEnvironments:[],enqueueInstanceInfo:[],globalEnvironment:this.env},this.env.useNestingDebug&&(this.trace.nestedTraces=[]))}nest({useNestingDebug:e=!1,useNestingVerbose:t=!1,useNestingLog:n=!1,useNestingSilent:a=!1}={useNestingDebug:!1,useNestingVerbose:!1,useLog:!1,useNestingSilent:!1}){return this.env=Object.freeze({...this.env,useDebug:e||this.env.useDebug,useNestingDebug:e||this.env.useNestingDebug,useVerbose:t||this.env.useVerbose,useNestingVerbose:t||this.env.useNestingVerbose,useLog:n||this.env.useLog,useNestingLog:n||this.env.useNestingLog,useSilent:a||this.env.useSilent,useNestingSilent:a||this.env.useNestingSilent}),this.lock(),async r=>this.start(...r)}formatOp(e,t){if(e instanceof s){let n=e.nest(this.env);return this.isPipelineFlagSet.add(n),n}else if(typeof e=="function")return pe(e,t)}pipe(e,t,n){if(!this.isMutable)throw Error("Attempted to add fallback Operation to a locked Pipeline.");let a=typeof e=="function",r=e instanceof s,i={...this.env,description:r?e.env.description:t,...n};if(r||a){let o=this.formatOp(e,i);o&&this.queue.push(o)}return this.env.useDebug&&this.trace&&typeof this.trace=="object"&&(this.trace.enqueueChildDescriptions.push(t??(r?e.env.description??"":"")),this.trace.enqueueLocalEnvironments.push(i),this.trace.enqueueInstanceInfo.push({isOp:a,isPipeline:r,isFallback:!1})),this}fallback(e,t,n){var o;if(!this.isMutable)throw Error("Attempted to add fallback Operation to a locked Pipeline.");if(this.queue.length<1)return this;let a=typeof e=="function",r=e instanceof s,i={...this.env,description:r?e.env.description:t,...n};if(r||a){let p=this.formatOp(e,i);if(p){let u=this.queue[this.queue.length-1],f=this.fallbackOps.get(u);f?f.push(p):(o=this.fallbackOps.set(u,[]).get(u))==null||o.push(p)}}return this.env.useDebug&&this.trace&&typeof this.trace=="object"&&(this.trace.enqueueChildDescriptions.push(t??(r?e.env.description??"":"")),this.trace.enqueueLocalEnvironments.push(i),this.trace.enqueueInstanceInfo.push({isOp:a,isPipeline:r,isFallback:!0})),this}lock(){return this.isMutable=!1,Object.freeze(this.queue),Object.freeze(this.fallbackOps),this}traceback(){return this.trace}async start(...e){var n;this.lock();let t={exitCode:1,error:Error(),errorMsg:"",pipe:e};try{this.env.useVerbose&&(console.log(`Starting Pipeline: "${this.env.description}"`),this.env.useDebug&&console.log("	",e));for(let a of this.queue){let r=await a(e);if(t.exitCode=r.exitCode,this.env.useDebug&&this.trace instanceof Object&&(this.trace.pipelineOutputs.push(r),this.trace.pipelineInputs.push(e),this.env.useNestingDebug&&"debugBackTrace"in r&&((n=this.trace.nestedTraces)==null||n.push(r.debugBackTrace))),r.exitCode===0){if(e=r.pipe,this.env.useDebug&&this.trace instanceof Object){let i=this.isPipelineFlagSet.has(a);this.trace.pipelineInstanceInfo.push({isFallback:!1,isOp:!i,isPipeline:i})}}else if(this.fallbackOps.has(a)){let o=this.fallbackOps.get(a);for(let p of o){let u=await p(e);if(t.exitCode=u.exitCode,this.env.useDebug&&this.trace&&typeof this.trace=="object"&&(this.trace.pipelineInputs.push(e),this.trace.pipelineOutputs.push(u)),u.exitCode===0){if(this.env.useDebug&&this.trace&&typeof this.trace=="object"){let f=this.isPipelineFlagSet.has(p);this.trace.pipelineInstanceInfo.push({isFallback:!0,isOp:!f,isPipeline:f})}e=u.pipe;break}else if(o.length-1===0)throw t.errorMsg=u.errorMsg,new Error("ERROR: Operations Pipeline had an unrecoverable failure: The main Operation failed, and every fallback Operation for it also failed.")}}else throw t.errorMsg=r.errorMsg,new Error("ERROR: Operations Pipeline had an unrecoverable failure: The main Operation failed, and there was no fallback Operation for it.")}t.exitCode=0}catch(a){a instanceof Error&&(t.error=a),t.exitCode=1,t.errorMsg=`ERROR! Error type: ${t.error.name}
Name of the Operation Pipeline that failed: "${this.env.description}"
Error exit code: ${t.exitCode}
Error output:  ${t.errorMsg}`,!this.env.useSilent&&(this.env.useLog||this.env.useShell||this.env.useDebug||this.env.useVerbose)&&console.error(t.errorMsg)}finally{this.env.useVerbose&&(console.log(`Finished Pipeline: "${this.env.description}"`),this.env.useDebug&&console.log("	",t.pipe)),this.env.useDebug&&this.trace&&typeof this.trace=="object"&&(t.debugBackTrace=this.trace),t.pipe=this.env.useEmptyLoopback&&this.queue.length===0&&e[0]instanceof Array?e[0]:e}return t}};var le=/[^\w@/.<>()|~^+*=? -]/gi,w=s=>s.replace(le,""),b=s=>s&&s.map(w);var S=k(require("readline")),v=require("process"),T=require("child_process"),L=require("util");var ue=s=>{let e=S.createInterface(s);return e.question=t=>new Promise(n=>{e.question(t,a=>{n(a)})}),e},De=ue({input:v.stdin,output:v.stdout});var de=(0,L.promisify)(T.execFile);var Q={execFile:de};var{execFile:ge}=Q,m=class s{static NPMSearchPkgRegex=/^[\w@/.-]+(?= {2,})|^[\w@/.-]+.+(?:[\r|\n|\r\n][\w@/.-]+(?=.+\| +\|).*)+/gim;static NPMSearchResultRegex=/(?=^[\w@/.-]+(?!.*\| +\|)(?:.*\n.+(?:\| +\|)+.*)*)/gim;static commands=["access","adduser","audit","bin","bugs","cache","ci","completion","config","dedupe","deprecate","diff","dist-tag","docs","doctor","edit","exec","explain","explore","find-dupes","fund","help","help-search","hook","init","install","install-ci-test","install-test","link","logout","ls","org","outdated","owner","pack","ping","pkg","prefix","profile","prune","publish","rebuild","repo","restart","root","run-script","search","set-script","shrinkwrap","star","stars","start","stop","team","test","token","uninstall","unpublish","unstar","update","version","view","whoami"];static argSanitize=w;static argvSanitize=b;#e="";#t="";view="";path="";conf=!1;search=[];set name(e){this.#e=s.argSanitize(e)}get name(){return this.#e}set version(e){this.#t=P.valid(P.coerce(e))??this.#t}get version(){return this.#t}constructor({name:e}){this.#e=s.argSanitize(e)}static async init({location:e,opts:t,raw:n}){let a=(0,g.cwd)();(0,g.chdir)(e);let r=await this.npmCommand("init",...t);return(0,g.chdir)(a),n?r:r.stdout}static async install({pkgs:e,location:t,opts:n,raw:a}){let r=(0,g.cwd)();(0,g.chdir)(t);let i=await this.npmCommand("install",...n,...e);return(0,g.chdir)(r),a?i:i.stdout}static async view({pkg:e,opts:t,raw:n}){let a=await this.npmCommand("view",...t,e);return n?a:a.stdout}static async search({terms:e,opts:t,raw:n}){let a=await this.npmCommand("search",...t,...e);return n?a:a.stdout}static async pack({pkgs:e,location:t,opts:n,cd:a,raw:r}){let i;if(a){let o=(0,g.cwd)();(0,g.chdir)(t),i=await this.npmCommand("pack",...n,...e),(0,g.chdir)(o)}else i=await this.npmCommand("pack",`--pack-destination ${t}`,...n,...e);return r?i:i.stdout}static async npm(...e){return await ge("npm",this.argvSanitize(e))}static async npmCommand(e,...t){if(!this.commands.includes(e))throw Error("Invalid or incompatible NPM command for NPM wrapper");return await this.npm(e,...t)}static innit=this.init;static create=this.init;static i=this.install;static in=this.install;static ins=this.install;static inst=this.install;static insta=this.install;static instal=this.install;static isnt=this.install;static isnta=this.install;static isntal=this.install;static isntall=this.install;static add=this.install;static v=this.view;static info=this.view;static show=this.view;static s=this.search;static se=this.search;static find=this.search},A=s=>Object.entries(s).map(e=>{let t=e[0],n=t.match(/[A-Z]/g);if(n)for(let r of n)t=t.replace(r,`-${r.toLowerCase()}`);let a=e[1]!==""?` ${e[1]}`:"";return`--${t}`+a}),he=s=>{let e=[{value:"",name:`Do not install: "${s.name}"`},{value:s.name,name:`Install: "${s.name}"`}];if(s.search.length>0)for(let t of s.search){let n=t.split("	",5);e.push({value:n[0],name:`${n[0]}  ${n[4]}  ${n[1]}  ${n[3]}  ${n[2]}`})}return e},q=async({pkg:s,opts:e,location:t})=>await m.pack({pkgs:[s.name],location:t,opts:A(e),cd:!0});var j=new d("Searching Registry For Packages",{useShell:!0}).pipe(({opts:s,args:e})=>{let t=[],n=0;for(let a of e)t[n]=new m({name:a}),n++;return{opts:s,pkgs:t}},"Creating Package List").pipe(async({opts:s,pkgs:e})=>{for(let t of e){let n=await m.search({opts:["--long","--parseable","--color=false"],terms:[t.name]});t.search=n.split(`
`).filter(a=>a!=="")}return{opts:s,pkgs:e}},"Searching For Possible Packages").pipe(async({opts:s,pkgs:e})=>{for(let t of e)t.view=await m.view({pkg:t.name,opts:["--color=true"]});return{opts:s,pkgs:e}},"Getting Info On Found Packages");var $=new d("Confirming Packages With User").pipe(async({opts:s,pkgs:e})=>{for(let t of e)t.conf=(await x.default.prompt({type:"confirm",name:"conf",default:!1,message:`${t.view||t.name}
Is this the correct package: "${t.name}"?`})).conf;return{opts:s,pkgs:e}},"Confirming Exact Packages").pipe(async({opts:s,pkgs:e})=>{for(let t of e){let n=`Do not install: "${t.name}"`;t.conf||(t.name=(await x.default.prompt({type:"list",name:"name",message:"Select the correct package:",default:n,choices:he(t)})).name,t.name!==""&&(t.conf=!0))}for(let t=e.length-1;t>=0;t--)e[t].conf===!1&&e.splice(t,1);return{opts:s,pkgs:e}},"Substituting Incorrect Packages");var B=new d("Installing Packages",{useShell:!0}).pipe(async({opts:s,pkgs:e,tmpDir:t})=>{let n=e.map(i=>i.name),a=A(s),r=await m.install({pkgs:n,opts:["--global-style","--no-save","--color=true",...a],location:t,raw:!0});return console.error(r.stderr),console.log(r.stdout),{opts:s,pkgs:e,location:t}},"Installing").pipe(({opts:s,pkgs:e,location:t})=>{for(let n of e)n.path=V.join(t,"node_modules",n.name);return{opts:s,pkgs:e}},"Saving Install Location");var z=require("os"),h=require("fs/promises"),J=require("fs-extra"),_=require("path");var{basename:me,join:y}=_.posix,U="package.json",H="utf8",W=async s=>{let e=y(s,U),t=await(0,h.readFile)(e,H);return JSON.parse(t)},X=async(s,e,t)=>{let n=y(s,U),a=JSON.stringify(e,void 0,2);return await(0,h.writeFile)(n,a,{encoding:H,signal:t})},Y=async(s="tmp-install-dir-")=>await(0,h.mkdtemp)(y((0,z.tmpdir)(),s)),K=async(s,e)=>await(0,J.move)(s,y(e,me(s)));var D=async s=>await(0,h.rm)(s,{recursive:!0});var l=require("commander");var Oe=require("commander"),be=(s,e)=>Number(e)+1,ve=(s,e)=>Number(e)+1,O=(0,l.createCommand)("npm-super-pack").version("0.1.0").description("A program to install NPM packages offline.").combineFlagAndOptionalValue(!1).usage("[options] package [packages...]").usage("[options] package [packages...] [--dest|--save [path]]").argument("<package>","The NPM package to install, is also used for installing offline packages.").option("--production=[boolean], --production","If true, save only the production dependencies of the package(s)").addOption(new l.Option("-P, --save-prod, --production=true, --production","Save the production dependencies of the package(s).")).addOption(new l.Option("-B, --save-bundle","Save the bundled dependencies of the package(s), this is the normal behavior of npm pack.")).addOption(new l.Option("-D, --save-dev, --production=false","Save both the production and dev dependencies of the package(s).").implies({saveProd:!0})).addOption(new l.Option("-O, --save-optional","Save the production, dev, and optional dependencies of the package(s).").implies({saveProd:!0,saveDev:!0})).addOption(new l.Option("--save-peer","Save the peer dependencies of the package(s).").implies({saveProd:!0})).addOption(new l.Option("--save <path>","Install package to file system location, also saves package to NPM's internal cache (_cacache).").conflicts("noSave")).addOption(new l.Option("--dest <path>","Install package to file system location, also saves package to NPM's internal cache (_cacache).").conflicts("noSave")).addOption(new l.Option("--pack-destination <path>","Install package to file system location, also saves package to NPM's internal cache (_cacache).").conflicts("noSave")).addOption(new l.Option("--package-destination <path>","Install package to file system location, also saves package to NPM's internal cache (_cacache).").conflicts("noSave")).addOption(new l.Option("--no-save",`Does not install package, only saves package to NPM's internal cache ("_cacache").`).conflicts("save")).option("-E, --save-exact","Saved dependencies will be configured with an exact version rather than using NPM's default semver range operator.").option("-n, --dry-run","Do not actually do anything, just print what would be done.").option("-f, --force","Override any warnings.").option("-v, --verbose","Print extra information.",be,0).addOption(new l.Option("--debug","Print debug information, use repeatedly to print more information.").implies({verbose:!0}).argParser(ve).default(0).preset(0)).option("--legacy-bundling","Eliminates all automatic deduping and causes npm to install the package such that versions of npm prior to 1.4, such as the one included with node 0.8, can install the package.").addOption(new l.Option("--omit <dependency types...>",'"prod", "dev", "optional", "bundle", or "peer" (can be set multiple times). Dependency types to omit from the installation. If a package type appears in both the --include and --omit lists, then it will be included.').choices(["prod","production","dev","optional","bundle","bundled","peer"])).addOption(new l.Option("--include <dependency types...>",'"prod", "dev", "optional", or "peer" (can be set multiple times). Allows for defining which types of dependencies to install. This is the inverse of --omit=<type>. Dependency types specified in --include will not be omitted, regardless of the order in which omit/include are specified on the command-line.').choices(["prod","dev","optional","peer"])).addOption(new l.Option("--strict-peer-deps","If set to true, and --legacy-peer-deps is not set, then any conflicting peerDependencies will be treated as an install failure.").conflicts("legacyPeerDeps")).addOption(new l.Option("--legacy-peer-deps","Causes npm to completely ignore peerDependencies, as in npm versions 3 through 6. If a package cannot be installed because of overly strict peerDependencies that collide, it provides a way to move forward resolving the situation. Use of legacy-peer-deps is not recommended, as it will not enforce the peerDependencies contract that meta-dependencies may rely on.").conflicts("strictPeerDeps")).option("--ignore-scripts","Eliminates all automatic deduping and causes npm to install the package such that versions of npm prior to 1.4, such as the one included with node 0.8, can install the package.").option("-y, --yes, --no-interactive, --auto, --automated","Assumes yes to all questions, and don't ask for user input.").option("-i, --interactive","Show pretty menus to view, select, confirm, or change packages.").option("--tag <tag>",'Install a package without giving a specific version, install the specified tag. ex: "latest"').option("--proxy [url]","A proxy to use for outgoing http requests. If the NPM HTTP_PROXY or http_proxy environment variables are set, proxy settings will be honored by NPM's underlying request library.").option("--https-proxy [url]","A proxy to use for outgoing https requests. If the NPM HTTPS_PROXY or https_proxy or HTTP_PROXY or http_proxy environment variables are set, proxy settings will be honored by the underlying make-fetch-happen library.").option("--no-proxy <domain extentions...>, --noproxy <domain extentions...>","Domain extensions that should bypass any proxies, (can be set multiple times). Also accepts a comma-delimited string. The default value is the NPM NO_PROXY environment variable.").option("--progress=[boolean], --progress","Display download and install progress reports. Default true.").option("--ignore-scripts <boolean>","If true, npm does not run scripts specified in package.json files. Note that commands explicitly intended to run a particular script, such as npm start, npm stop, npm restart, npm test, and npm run-script will still run their intended script if ignore-scripts is set, but they will not run any pre-scripts or post-scripts. Default false.").option("--no-progress","Eliminates all progress reporting.").option("--prefer-online","If true, NPM staleness checks for cached data will be forced, always looking for fresh package data.").option("--prefer-offline","If true, NPM staleness checks for cached data will be bypassed, but missing data will be requested from the server. To force full offline mode, use --offline.").option("--offline","If true, NPM packages will be not be downloaded, but be sourced from the previously installed backups or NPM's cache.").option("--package <packages...>, --packages <packages...>","Clearly define the names of the package(s) to be installed.").option("--node-version",`The nodeJS version to use when checking a package's "engines" setting.`).option("--max-sockets <number>, --maxsockets <number>","The maximum number of connections to use per origin (protocol/host/port combination).").option("--foreground-scripts","Run all NPM build scripts (preinstall, install, and postinstall) for installed packages in the foreground process, sharing standard input, output, and error with the main NPM process. Note that this will generally make installs run slower, and be much noisier, but can be useful for debugging.").addOption(new l.Option("--loglevel <level>, --log-level <level>, --npm-log-level <level>","The logging detail NPM uses.").choices(["silent","error","warn","notice","http","timing","info","verbose","silly"])),F=new d("Argument Parser").pipe(({argv:s,parser:e})=>(s===process.argv&&(s=s.slice(2)),{argv:s,parser:e}),"Prepare ArgV").pipe(({argv:s,parser:e})=>({args:b(s),parser:e}),"Input Sanitization").pipe(({args:s,parser:e})=>e.parse(s,{from:"user"}),"Parsing Commands, Arguments, And Options"),Pe=(s=process.argv,e=O,t=F)=>t.start({argv:s,parser:e}),E=async(s=process.argv.slice(2))=>(await Pe(s,O)).pipe[0],Qe=E();(async()=>{var r;let s,e=await E(),t=((r=e.opts)==null?void 0:r.call(e))??{},n=async(...i)=>{t.verbose&&console.log(...i)},a={useVerbose:!!t.verbose||!!t.debug,useDebug:!!t.debug||t.verbose>=2,useNestingDebug:t.debug>=2||t.verbose>=3};t.verbose="",t.debug="",await new d("Back Up Packages",{...a,useNestingLog:!0}).pipe(F).pipe(i=>{let o=i.opts();return o.verbose="",o.debug="",o.dest=o.dest??o.save??o.packDestination??o.packageDestination,o.packDestination=o.packDestination??o.dest??o.save??o.packageDestination,delete o.save,delete o.packageDestination,{opts:o,args:i.args}},"Convert CLI Responce").pipe(new d("Finding Packages").pipe(j).pipe($)).pipe(new d("Backup Process").pipe(new d("Preparing For Backup").pipe(async({opts:i,pkgs:o})=>(s=await Y(),{opts:i,pkgs:o,tmpDir:s}),"Creating Temporary Install Directory")).pipe(new d("Backing Up Packages").pipe(B).pipe(async({opts:i,pkgs:o,tmpDir:p})=>{for(let u of o){let f=u.path,c=await W(f);c&&i.save&&("bundledDependencies"in c&&c.bundledDependencies instanceof Array?(i.saveProd&&c.bundledDependencies.push(...Object.keys(c.dependencies)),i.saveDev&&c.bundledDependencies.push(...Object.keys(c.devDependencies)),i.saveOptional&&c.bundledDependencies.push(...Object.keys(c.optionalDependencies)),i.savePeer&&c.bundledDependencies.push(...Object.keys(c.peerDependencies))):(c.bundleDependencies=c.bundleDependencies instanceof Array?c.bundleDependencies:[],i.saveProd&&c.bundleDependencies.push(...Object.keys(c.dependencies)),i.saveDev&&c.bundleDependencies.push(...Object.keys(c.devDependencies)),i.saveOptional&&c.bundleDependencies.push(...Object.keys(c.optionalDependencies)),i.savePeer&&c.bundleDependencies.push(...Object.keys(c.peerDependencies)))),await X(f,c)}return{opts:i,pkgs:o,tmpDir:p}},"Preparing Packages").pipe(async({opts:i,pkgs:o,tmpDir:p})=>{for(let u of o)await q({pkg:u,location:i.dest??p,opts:i});return{pkgs:o,opts:i,tmpDir:p}},"Packing Packages").fallback(async({opts:i,pkgs:o,tmpDir:p})=>{for(let u of o)await K(u.path,i.dest??(0,G.cwd)());return{pkgs:o,opts:i,tmpDir:p}},"Moving Packages")).pipe(async(...i)=>(await D(s),i),"Clean Up After Backup",{useLoopback:!0}).pipe((...i)=>(n("Finished Backup!"),i),"Output Success",{useLoopback:!0})).fallback(async(...i)=>(n("FATAL ERROR!"),await D(s),i),"Clean Up After Error",{useLoopback:!0}).start({argv:process.argv,parser:O})})();
//# sourceMappingURL=backup.js.map
